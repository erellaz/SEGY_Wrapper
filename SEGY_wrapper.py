"""Segy import and export from and to Numpy array, intended to provide an easy 
SEGY input/output to various Python forward modeling propagators.
Based on SEGYIO and Obspy (for SEGY writing)
2021-04-13 by Erellaz
MIT License
"""

#______________________________________________________________________________
import matplotlib.pyplot as plt
import segyio
import numpy as np

#______________________________________________________________________________
def CourantCondition(dx,num_dims,Vmax):
    """Courant–Friedrichs–Lewy stability condition. Find the maximum stable 
    time step allowed by the grid cell size and maximum velocity."""
    return np.min(dx)/(num_dims**.5*Vmax)

#______________________________________________________________________________
def Segy2Numpy(segyfile, subsetz=(None,None,None), subsety=(None,None,None), verbose=True, pictures=True, savez=True):
    """
    Read a SEGY dataset and save a subset (or all of it) into a numpy array.
    Perform diagnostics and QCs. 2D or 3D. 
    If the dataset is 3D, the user should reshape the NumpyArray after calling 
    this function.
    Arguments:
    -segyfile: name or full path to a valid SEGY file
    -subsetz, subsety: slice in the z and y direction, default: selec all
    -verbose: print EBCDIC header, binary header and some trace parameters, default: True
    -pictures: display and save pictures of the full and subset of the segy, default: True
    -savez: save the data in compressed numpy array form on disk, named from SEGY
    """
    
    # Read the Segy with SEGYIO
    f = segyio.open(segyfile, ignore_geometry=True)
    vels=f.trace.raw[:].T
    n_traces = f.tracecount
    sample_rate = segyio.tools.dt(f) / 1000
    ebcdic_header = segyio.tools.wrap(f.text[0])
    bin_headers = f.bin
    vmin, vmax = np.percentile(vels, [0,100])
    #spec = segyio.tools.metadata(f)
    if verbose:
        print(ebcdic_header)
        print("\n\n")
        print(bin_headers)
        print("\n\n")
        print("Sample rate:",sample_rate)
        print("Number of Traces:",n_traces)
        # Find the min and max value in the dataset
        print("Velocity array size:",vels.shape)  
        print("Vmin, Vmax", vmin,vmax)
    
    
    if pictures:
        # Plot the data
        plt.imshow(vels, cmap=plt.cm.jet, vmin=vmin, vmax=vmax)
        # Or just save the image to disk
        plt.imsave(segyfile+'.png',vels,cmap=plt.cm.jet, vmin=vmin, vmax=vmax)
    
    
    # Take a subset
    vels_sub=vels[subsetz[0]:subsetz[1]:subsetz[2],subsety[0]:subsety[1]:subsety[2]] #numpy slicing with start:stop:step
    #vels2=vels[::,2000:4000] #numpy slicing with start:stop:step
    if verbose:
        print("Velocity array subset size:",vels_sub.shape)
    if pictures:
        plt.imshow(vels_sub,cmap=plt.cm.jet, vmin=vmin, vmax=vmax)
        plt.imsave(segyfile+'.png',vels_sub,cmap=plt.cm.jet, vmin=vmin, vmax=vmax)
    
    
    # Save (a subset) to numpy array
    if savez:
        np.savez(segyfile+'.npx',vels_sub)
        
    return vels_sub

#______________________________________________________________________________
from obspy import Trace, Stream
from obspy.core import AttribDict
from obspy.io.segy.segy import SEGYTraceHeader, SEGYBinaryFileHeader

def Numpy2Segy(Segy_name,shots, Sample_int, verbose=True, pictures=True, EBCDIC=None):
    """
    Export to SEGY shots generated by a Wave Equation Propgator, eg Deepwave
        -Load the numpy array contaijing all shots generated by the propagator
        -Save one picture per shot
        -Export the shots in from Numpy to SEGY, one SEGY per shot
        
        To export SEGYs we will call SEGYIO through Obspy, 
        which is much easier than SEGYIO when creating segys from scratch.
        
        Arguments:
            -segy_name: radical name or full path + radical to the desired output
            -Shots: numpy array for the shots
            -verbose: print EBCDIC header, binary header and some trace parameters, default: True
            -pictures: display and save pictures of the fshots, default: True
            -EBCDIC: default or custom EBCDIC header
    
    """
    #______________________________________________________________________________

    
    ebcdic_header="""C 1  Synthetic Shot created from Deepwave
    C 2  Velocity used: 
    C 3  Forward modeling parameters:
    C 4  freq = 
    C 5  dx = 
    C 6  dt = 
    C 7  nt = 
    C 8  num_dims = 
    C 9  
    C10  Survey parameters
    C11  num_shots = 
    C12  num_sources_per_shot = 
    C13  num_receivers_per_shot = 
    C14  source_spacing =  # meters
    C15  receiver_spacing =  # meters
    C16
    C17  Compute parameters, CPUs or GPUs
    C18
    C19  device = 
    C20  velname=
    C21  time_decim=
    C22
    C23 
    C24 
    C25 
    C26
    C27 
    C28 
    C29 
    C30 
    C31 
    C32
    C33 
    C34 
    C35 
    C36
    C37 
    C38 
    C39 
    C40 """
    
    Sample_int=int(Sample_int)
    #______________________________________________________________________________
    # Load the shots
    (t_sample,nbr_of_shots,nbr_of_traces)=shots.shape # find the array dimensions
    print("t_sample,nbr_of_shots,nbr_of_traces:",t_sample,nbr_of_shots,nbr_of_traces)
    
    #______________________________________________________________________________
    # QC those shots & save 1 image for each
    for shot_index in range(nbr_of_shots):
        print("Processing Shot:",shot_index)
        shot=shots[:,shot_index,:]
        vmin, vmax = np.percentile(shot, [1.5,98.5])
        if pictures:
            plt.imsave('Shot_'+str(shot_index)+'.png',shot,cmap=plt.cm.seismic, vmin=-vmax, vmax=vmax)
    
        # Output one SEGY for each shot
        stream = Stream()
        for _i in range(nbr_of_traces):
            # Create some random data.
            data = shot[:,_i]
            data = np.require(data, dtype=np.float32)
            trace = Trace(data=data)
        
            # Attributes in trace.stats will overwrite everything in
            # trace.stats.segy.trace_header
            trace.stats.delta = Sample_int/1000
        
            # If you want to set some additional attributes in the trace header,
            # add one and only set the attributes you want to be set. Otherwise the
            # header will be created for you with default values.
            if not hasattr(trace.stats, 'segy.trace_header'):
                trace.stats.segy = {}
            trace.stats.segy.trace_header = SEGYTraceHeader()
            trace.stats.segy.trace_header.trace_sequence_number_within_line = _i + 1
            trace.stats.segy.trace_header.trace_sequence_number_within_segy_file = _i + 1
            trace.stats.segy.trace_header.ensemble_number= _i + 1    
            trace.stats.segy.trace_number_within_the_ensemble= 1         
            trace.stats.segy.trace_header.receiver_group_elevation = 0
            #print(trace.stats.segy.trace_header)
            # Add trace to stream
            stream.append(trace)
        
        # A SEGY file has file wide headers. This can be attached to the stream
        # object.  If these are not set, they will be autocreated with default
        # values.
        stream.stats = AttribDict()
        stream.stats.textual_file_header = ebcdic_header
        stream.stats.binary_file_header = SEGYBinaryFileHeader()
        stream.stats.binary_file_header.trace_sorting_code = 5 # Common source point sort order
        stream.stats.binary_file_header.data_sample_format_code = 1 # 4 bytes IBM 32 bits sample encoding, needs to be consistent with data encoding in stream.write 
        stream.stats.binary_file_header.sample_interval_in_microseconds=Sample_int
        stream.stats.binary_file_header.number_of_data_traces_per_ensemble= 1 # 
        stream.stats.binary_file_header.ensemble_fold= 1 # pre-stack
        stream.stats.binary_file_header.number_of_samples_per_data_trace=t_sample # from the numpy array shape
        stream.stats.binary_file_header.measurement_system=1 # meters
        stream.stats.binary_file_header.impulse_signal_polarity=1 # meters
        stream.stats.binary_file_header.fixed_length_trace_flag=1 # all traces are guarantied of same size
        
        if verbose:
            print(stream.stats.textual_file_header)
            print(stream.stats.binary_file_header)
            print(trace.stats.segy.trace_header)
            print("Stream object before writing...")
            print(stream)
            print("Shot_"+str(shot_index)+".sgy")
        
        stream.write("Shot_"+str(shot_index)+".sgy", format="SEGY", data_encoding=1,byteorder='>') # write in IBM float, Big Indian to be standard